`script` is a simple script engine written in golang with Lua-like syntax. [Playground](http://play.fweibo.com)

(If you are looking for a Lua 5.2 compatible engine, refer to tag `v0.2`)

## Can & Can't

- You can't create closures inside the script, but you can return functions to Go callers which naturally have one
- You can't use `bool`, actually `true == 1 and false == 0`. If you do want them, use `True` and `False`
- You can't use `table`, there is no out-of-box support for it, nor for array. If you write `{a = 1, ["b"] = 2}`, you will get a JSON STRING instead of `table`
- You can `return` anywhere in the function, and `yield` not only the results but also the state of the function, so you can resume it later ([play](http://play.fweibo.com/?src=nvAANc)):
    ```lua
    function foo() yield 1; yield 2; return 3; end
  
    local a, ... = foo()            -- a == 1
    local a, ... = resume(foo, ...) -- a == 2
    local a, ... = resume(foo, ...) -- a == 3
	-- state is cleared
    ```
- You can `goto` anywhere in a function so be careful about uninitialized variables.
- You can `+=`, `-=`, `*=`, `/=` and `%=`.
- You can use `...` to catch returned arguments and name it if you like ([play](http://play.fweibo.com/?src=r8vl6P)):
	```lua
	function foo() return 1, 2, 3 end
	
	local n, ... = foo()
	print(...)

	local a, b, ...c = foo()
	print(c)
	```
- You can directly access `#...` and `...[index]`, here is an array workaround using this trick ([play](http://play.fweibo.com/?src=Hxxnhx)):
	```lua
	function array(...) return ... end
 
	local ...arr = array(1, 2, 3)
	for i = 1, #arr do assert(i == arr[i]) end
    ```
- You can define more than 255 variables in a function (up to ~4000, depending on the number of temporal variables generated by interpreter)
- You can call a function optionally (say `foo` has 26 parameters from `a` to `z`): `foo(a=1, m=2, z=3)`
- You can slice `string`, `...`, `reflect.Slice` and/or `reflect.Array`: `("string")[1,3] == "str"`, `a[1,2]`. Always keep in mind that index starts from 1 and ends inclusively
- [return vs return nil](https://stackoverflow.com/questions/18522299/returning-nil-from-a-lua-function-in-c-vs-returning-0-values): they are EXACTLY IDENTICAL to each other in `script`, so you will get three `1` as outputs
- `number` is `int64+float64` internally, math operations may promote it to `float64` when needed and downgrade it to `int64` when possible

## Run

```golang
program, err := script.LoadString("return 1, 2, 3")
v, v1, err := program.Run() // v == 1, v1[0] == 2, v1[1] == 3
```

Every function must return at least one `script.Value` (e.g.: `v` in the above code), if it returns multiple values, then the rest ones are stored in `v1` (`[]script.Value`).

### Global Values

```golang
script.AddGlobalValue("G", func() int {
	return 1
})

program, _ := script.LoadString("return G() + 1")
v, v1, err := program.Run() // v == 2

program, _ = script.LoadString("return G() + 2")
v, v1, err = program.Run() // v == 3

program, _ = script.LoadString("return G + 2", CompileOptions{
	GlobalKeyValues: {
		"G": 10, // override the global 'G'
	},
})
v, v1, err = program.Run() // v == 12
```

## Benchmarks

Refer to [here](https://github.com/coyove/potatolang/blob/master/tests/bench/perf.md).

