for i, v, n in ipairs({1, 2, 3}) do
    assert( i == v and n == nil)
end

local n, s, ii = ipairs({1, 2, 3})
for i, v, n in n,s,ii do
    assert( i == v and n == nil)
end


assert(require "goto.txt" == "goto")

local a, b, c = (function() return 1, 2, 3 end)()
assert(a == 1 and b == 2 and c == 3)

a,b,c = (function (a, b ,c)
    local function f(a, b) return b, a end
    b, c = f(b, c)
    return c, b, a
end)(1,2,3)
assert(a == 2 and b == 3 and c == 1)

for v1, v2 in (function() 
    yield 1, 1
    yield 2, 2
end) do
    assert(v1 != nil and v1 == v2)
end

function syntax_return_void() return end
function syntax_return_value(en) return en end
function syntax_return_void2(en) return
en end
assert(syntax_return_void2(1) == nil)

ex = {1, 2}
ex[1], ex[2], ex3 = ex3, ex[1], ex[2]
assert(ex3 == 2 and ex[1] == nil and ex[2] == 1)

do
    local ms = {}
    ms[1], ms2 = (function () return 1, 2 end)()
    assert(ms[1] == 1 and ms2 == 2)
end
assert(ms == nil and ms2 == 2)


local a = native.bytes(2)
a[0] = 49
a = a:append(unpack({32 , 33, 34}))
assert(a == {49,0,32,33,34} and {49,0,32,33,34} == a)
assert(a:tostring() == "1\x00 !\"")
assert(a == "1\x00 !\"" and a == native.bytes(a:tostring()))

local str = require "string.txt"
assert(str.name == "abc")

require "string.txt"
assert(string.name == "abc")

do
    scope = 1
    assert(scope == 1)
end
assert(scope == 1)

do
local a, i = {}, 1
a[1 + i ] = i;
(function () return a end)().test = 1
assert(a[2] == 1 and a["test"] == 1)
end

function callstr(a) 
    return a .. "a"
end

assert(callstr"a" == "aa")

local iii = 3
t = {1, 2, (1 + iii - 1); a = "a", ["" .. "b"] = "b"}
for k, v in pairs(t) do
    assert(k == v)
end
assert(k == nil and v != 3) -- k, v in the above for-loop are now dropped

for i = 1,3 do
    assert(t[i] == i)
end
assert(i == nil)

t, step, ii = {10,8,6,4,2}, -2, 1
for i = 10,1,step do
    assert(t[ii] == i)
    ii+=1
end

function vararg(a, b, ...) 
    local c = a * (b + a) + b
    assert(c == 5)
    for i =1, select("#",...) do
        local iv = select(i, ...)
        assert(iv == i + 2)
        ...[i]+=1
    end
    return {select("#",...), ...}
end

vararg(1, 2, 3, 4, 5);
result = vararg(1, 2, unpack({3, 4, 5}))
assert(result[1] == 3 and result[4] == 6)

do
    t = {3, 4, 5}
    vararg(1, 2, unpack(t))
    -- Now t should be {4, 5, 6}
    i = 1
    repeat
        assert(t[i] == i + 3)
        i+=1
    until i == 4
end

a = 0
assert(a == 0)

local a , b = 1, 2
assert(a == 1)
assert(b == 2)

if false then
    assert(false)
elseif a == 1 then
    local a = 3
    a = a + 2 - b
    assert(a == 3)
elseif true then
    assert(false)
end

assert(a == 1)

function add(a,b) return a + b end

fib2 = function(a, b)
   while true do
       c = add(a, b)
       a = b
       b = c
       yield c
   end
end

fib3 = closure.copy(fib2)
 
fib_seq = { 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, }
for i = 0,32 do assert(fib_seq[i +1] == fib2(0,1)) end

assert( (fib2())==9227465)
assert( (fib3(0, 1)+fib3()+fib3()+fib3()) == 11)

function yieldtest()
    yield 1
    yield 2
    yield 3
end

assert(yieldtest() ==1 and yieldtest()==2 and yieldtest()==3 and yieldtest()==nil)
assert(yieldtest() ==1 and yieldtest()==2 and yieldtest()==3 and yieldtest()==nil)
 
function counter() for i= 3,1,-1 do yield i end end
function yieldtest() while true do yield ({3, 2, 1})[counter()] end end
assert( yieldtest() ==1 and yieldtest()==2 and yieldtest()==3 )

function deepadd(a)
    if (a <= 0) then return 0 end
    return add(a, deepadd(a - 1))
end

e = 100000
assert( deepadd(e) == (1 + e) * (e / 2 ))
 
a = 2
assert( 1 + 2 *3/5 == 2.2)
assert( 1 /2+ 2.2 * (a + 1) * 5 == 33.5)

mul = (function (a) b = 1 return function() b = b * a; return b end end)(2)
assert( mul() == 2 and mul() == 4 and mul() == 8)

--[[

double = (func a = func b = a * b)(2)
assert( double(2) == 4)

if (1||func() {assert(0) }) {
    assert( 1)
}

if (0&&func() {assert(0) }) {
    assert( 1)
}

func test2() {
    func test1() {
        sum = 0
        for i = range 0, 99 {
            sum = sum + i
            if (sum > 100) { break }
        }
        assert( sum == 105)
    }
    test1()
}

test2()

m = {
    key1: "value1",
    key2: {1,2,3}
}

assert( m == m())

m3 = m()
m.key2[0] = 0
assert( m3.key2[0] == 1&&m.key2[0] == 0)

func select(cond, t, f) {
    return cond&&t||f
} 

assert( 1&&1||0)
assert( 0&&0||1)
assert( select(1, 1, 2) == 1&&select(0, 1, 2) == 2)
a = 1
a = a - 1  // this will be eventually compiled into: [inc a -1]
assert( a == 0)

_array = {1,2,3}
assert( len(_array)==3)

_array = {1,2,3,}
assert( len(_array)==3)


af = 2

if (af == 0)
    af = 1
else 
    if (af == 1)
        af = 2
    else    
        af = 3

assert( af == 3)

af = 1

if (af == 0)
    if (af < 2)
        assert( 1)
else
    assert( 0)  // shouldn't be here

a = import "simple.txt" + 1
assert( a == 2)

func safeexec() {
    assert( 0)
}
std.Safe(safeexec)
safeexec()

m = {1,2,{1,2,{1,2,{1,2,3}}}}
m[2][2][2][2] = 4
assert( m == {1,2,{1,2,{1,2,{1,2,4}}}})

func safeexec(f, args...) {
    result = nil
    x = std.Safe(func () {
        result = f(args...)
    })()

    return result, x == nil
}

r, ok = safeexec(func(a, b) {
    return a / b
}, 1, 2)
 
assert(r== 0.5)

r, ok = safeexec(func a, b = a / b, 1, "2")
  
assert(r== nil && !ok)

a = func a = func b = func c = a + b + (func d = d * 2)(c)
assert( a(1)(2)(3) == 9)

assert( (func a... = a)(1,2,3) == {1,2,3})
assert( (func a... = a)({1,2,3}...) == {1,2,3})
assert( (func b, a... = a)({1,2,3}...) == {2,3})
assert( (func b, a... = a)({1,2}...,{3,4}...) == {2,3,4})
assert( (func b, a... = a)("hello") == {})

func multi_return(a, b) {
    yield a + 1
    yield b + 1
    return a + b 
}

mr_a = multi_return(1, 2)
mr_b = multi_return()
mr_ab2 = ({a: multi_return})().a()
mr_ab = multi_return()

assert( mr_a == 2&&mr_b == 3&&mr_ab == 3&&mr_ab2 == 3)

x = 10
(func() { x = 2 })()
assert( x == 2)

x = 10
(func() { x := 2 * x assert( x == 20) })()
assert( x == 10)

a = {1, 2, 3, "a", "b" , "c"}
n = copy(a[1:3], {"2", "3"})
assert( n == 2&&a == {1, "2", "3", "a", "b", "c"})

b = append(a[:4], {4}..., {5}...)
assert (b == {1, "2", "3", "a", 4, 5} && a == b)

c = append(a, 1, 2)
assert(a == b && c == {1, "2", "3", "a", 4, 5, 1, 2})

a = {1, 2, 3}
idx = len(a)
a[idx] = 4
assert(a == {1, 2, 3, 4})
]]
