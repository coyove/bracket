func add(a,b) return a + b

fib2 = func(a, b) {
   for true {
       c = add(a, b)
       a = b
       b = c
       yield c
   }
}

fib3 = std.dupcls(fib2)
 
for i = 0,33 fib2(0,1)

assert( (fib2())==9227465)
assert( (fib3(0, 1)+fib3()+fib3()+fib3()) == 11)

func yieldtest() {
    yield 1
    yield 2
    yield 3
}

assert( yieldtest() ==1&&yieldtest()==2&&yieldtest()==3&&yieldtest()==nil)
assert( yieldtest() ==1&&yieldtest()==2&&yieldtest()==3&&yieldtest()==nil)

func counter() for i=2,0,-1 yield i

func yieldtest() for true yield ({3, 2, 1})[counter()]

assert( yieldtest() ==1&&yieldtest()==2&&yieldtest()==3 )

func deepadd(a) {
    if (a <= 0) { return 0 }
    return add(a, deepadd(a - 1))
}

e = 100000
assert( deepadd(e) == (1 + e) * (e / 2 ))

a = 2
assert( 1 + 2 *3/5 == 2.2)
assert( true /2+ 2.2 * 5 * (a + 1) == 33.5)
assert( 1 /2+ 2.2 * (a + 1) * 5 == 33.5)

l = {1,2,3}
l2 = {"1","2","3"}
l[len l-1+1] = l2
assert( l == {1,2,3, {"1","2","3"}})
assert( (l << l2) == {1,2,3, {"1","2","3"}, "1", "2", "3"})

mul = (func(a) { b = 1 return func() {b = b * a return b } })(2)

assert( mul() == 2&&mul() == 4&&mul() == 8)
if (0 == 1 ) {
    assert( 0)
} else if (2 == 2) {
    assert( 1)
} else {
    assert( 0)
}

double = (func a = func b = a * b)(2)
assert( double(2) == 4)

if (1||func() {assert(0) }) {
    assert( 1)
}

if (0&&func() {assert(0) }) {
    assert( 1)
}

func test2() {
    func test1() {
        sum = 0
        for i =0, 100 {
            sum = sum + i
            if (sum > 100) { break }
        }
        assert( sum == 105)
    }
    test1()
}

test2()

m = {
    key1: "value1",
    key2: {1,2,3}
}

assert( m == m())

m3 = m()
m.key2[0] = 0
assert( m3.key2[0] == 1&&m.key2[0] == 0)

func select(cond, t, f) {
    return cond&&t||f
} 

assert( 1&&1||0)
assert( 0&&0||1)
assert( select(1, 1, 2) == 1&&select(0, 1, 2) == 2)
a = 1
a = a - 1  // this will be eventually compiled into: [inc a -1]
assert( a == 0)

_array = {1,2,3}
assert( len(_array)==3)

_array = {1,2,3,}
assert( len(_array)==3)


af = 2

if (af == 0)
    af = 1
else 
    if (af == 1)
        af = 2
    else    
        af = 3

assert( af == 3)

af = 1

if (af == 0)
    if (af < 2)
        assert( 1)
else
    assert( 0)  // shouldn't be here

a = import "simple.txt" + 1
assert( a == 2)

func safeexec() {
    assert( 0)
}
std.safe(safeexec)
safeexec()

m = {1,2,{1,2,{1,2,{1,2,3}}}}
m[2][2][2][2] = 4
assert( m == {1,2,{1,2,{1,2,{1,2,4}}}})

func safeexec(f, args) {
    result = "none"
    x = std.safe(func () {
        result = std.apply(f, args)
    })()

    return {
        result: result,
        ok: x == nil,
    }
}

r = safeexec(func(a, b) {
    return a / b
}, {1,2})
 
assert( r.result == 0.5)

r = safeexec(func(a, b) {
    return a / b
}, {1,"2"})
  
assert( r.result == "none"&&!r.ok)

a = func a = func b = func c = a + b + (func d = d * 2)(c)
assert( a(1)(2)(3) == 9)

assert( (func a... = a)(1,2,3) == {1,2,3})
assert( (func a... = a)({1,2,3}...) == {1,2,3})
assert( (func b, a... = a)({1,2,3}...) == {2,3})
assert( (func b, a... = a)({1,2}...,{3,4}...) == {2,3,4})

func multi_return(a, b) {
    yield a + 1
    yield b + 1
    return a + b 
}

mr_a = multi_return(1, 2)
mr_b = multi_return()
mr_ab2 = ({a: multi_return})().a()
mr_ab = multi_return()

assert( mr_a == 2&&mr_b == 3&&mr_ab == 3&&mr_ab2 == 3)

x = 10
(func() { x = 2 })()
assert( x == 2)

x = 10
(func() { $x = 2 * x assert( $x == 20) })()
assert( x == 10)

a = {1, 2, 3, "a", "b" , "c"}
n = len ({"2", "3"})(a[1:3])
assert( n == 2&&a == {1, "2", "3", "a", "b", "c"})
