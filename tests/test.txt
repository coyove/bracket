func add(a,b) {return a + b;}

var fib2 = func(a, b) {
    for (1) {
        var c = add(a, b);
        a = b;
        b = c;
        yield c;
    }
};
 
 var fib3 = copy(fib2);
 
for (var i = 0;i < 33; i = i + 1) {
     fib2(0, 1) ;
 }

assert (fib2())==9227465 ;
assert (fib3(0, 1)+fib3()+fib3()+fib3()) == 11;

func yieldtest() {
    yield 1;
    yield 2;
    yield 3;
}

assert yieldtest() ==1  && yieldtest()==2 && yieldtest()==3 && yieldtest()==nil;

func deepadd(a) {
    if (a <= 0) { return 0 ;}
    return add(a)(deepadd(a - 1));
}

var e = 100000; 
assert deepadd(e) == (1 + e) * (e / 2 );

var a = 2;
assert 1 + 2 *3/5 == 2.2;
assert 1 /2+ 2.2 * 5 * (a + 1) == 33.5;
assert 1 /2+ 2.2 * (a + 1) * 5 == 33.5;

var l = {1,2,3}, l2= {"1","2","3"};
assert (l + l2) == {1,2,3, {"1","2","3"}};
assert (l & l2) == {1,2,3, "1", "2", "3"};
assert l == {1,2,3};

var mul = (func(a) {var b = 1; return func() {b = b * a; return b; }; })(2);

assert mul() == 2 && mul() == 4 && mul() == 8;
if (0 == 1 ) {
    assert 0;
} else if (2 == 2) {
    assert 1;
} else {
    assert 0;
}

if (1 || func() {assert 0; }) {
    assert 1;
}

if (0 && func() {assert 0 ;}) {
    assert 1;
}

func returncond(n) {
    return {
        "counter": n,
        "test": func(this) {
            this.counter = this.counter + 1;
            return this.counter % 2 == 0;
        }
    };
}

var cond = returncond(0);
assert cond.test() || cond.test();
cond.test();
assert cond.test() && !cond.test();


func test2() {
    func test1() {
        var sum = 0;
        i = 0; for (; i < 100 ; i=i+1) {
            sum = sum + i;
            if (sum > 100) { break; }
        }
        assert sum == 105;
    }
    test1();
}

test2();

var m = {
    "key1": "value1",
    "key2": {1,2,3}
};

assert m == copy(m);
var m2 = {};
m2.key1 = "value1";
m2.key2 = {};
i = 1 ;for (;i < 4; i = i + 1) { m2.key2 = m2.key2 + i; }
assert m2 == m;

a = 0i0;
var b = 0iffffffffffffffff;
assert math.u64.eq(math.u64.xor(a, b), b);
a = math.u64.eq(12);
assert a(12);

func select(cond, t, f) {
    return cond && t || f;
} 

assert 1 && 1 || 0;
assert 0 && 0 || 1;
assert select(1, 1, 2) == 1 && select(0)(1)(2) == 2;
a = 1;
a = a - 1 ; // this will be eventually compiled into: [inc a -1]
assert a == 0;

var counter = {
    "tick" : 0,
    "add": func(this, step) {
        this.tick = this.tick + step;
    },
};

var c = copy(counter);
c.add()(2);
c.add(1);
assert c.tick == 3;

var _array = {1,2,3};
assert len(_array)==3;

_array = {1,2,3,};
assert len(_array)==3;


var af = 2;

if (af == 0)
    af = 1;
else 
    if (af == 1)
        af = 2;
    else    
        af = 3;

assert af == 3;

var af = 1;

if (af == 0)
    if (af < 2)
        assert 1;
else
    assert 0;  // shouldn't be here

var a = require "simple.txt" + 1;
assert a == 2;

func! safeexec() {
    assert 0;
}

safeexec();

var m = {1,2,{1,2,{1,2,{1,2,3}}}};
m[2][2][2][2] = 4;
assert m == {1,2,{1,2,{1,2,{1,2,4}}}};

func safeexec(f, args) {
    var result = "none";
    var x = (func! () {
        result = std.apply(f, args);
    })();

    var b = x == nil;
    var a = result;
    return copy();
}

var r = safeexec(func(a, b) {
    return a / b;
}, {1,2});
 
assert #r == 0.5;

var r = safeexec(func(a, b) {
    return a / b;
}, {1,"2"});
  
assert #r == "none" && !#r ;
