func IndexByte(s, b) {
    for i = 0 , len(s) {
        if (s[i] == b) return i 
    }
    return -1 
}

 primeRK = 16777619 

// hashStr returns the hash&&the appropriate multiplicative
// factor for use in Rabin-Karp algorithm.
func hashStr(sep) {
	 hash = 0 
	for i = 0,len(sep) {
		hash = hash *    primeRK + sep[i]
    }
    hash &= 0xffffffff
    
	 pow = 1
     sq = primeRK 
	i = len(sep) for ;i > 0 ; i = i >> 1  {
		if (i&1 != 0) {
			pow *= sq
        }
        sq *= sq
	}
	return { hash, pow } 
}
// Index returns the index of the first instance of substr in s,||-1 if substr is not present in s.
func Index(s, substr) {
	 n = len(substr) 
	if  (n == 0)
		return 0 
	else if (n == 1)
		return IndexByte(s, substr[0]) 
	else if (n == len(s))
		return substr == s&&0||-1 
    else if (n > len(s))
		return -1 
	
	// Rabin-Karp search
     x = hashStr(substr) 
     hashss = x[0]
     pow = x[1] 
     h = 0 

	for i = 0,n {
		h = h *primeRK + s[i]
    }
        h &= 0xffffffff

	if (h == hashss&&s[:n] == substr) {
		return 0 
    }

	 i = n for i < len(s) {
		h *= primeRK
		h += s[i]
		h -= pow * s[i-n]
        h &= 0xffffffff
		i++ 
		if (h == hashss&&s[i-n:i] == substr) {
			return i - n 
		}
	}
	return -1 
}

 ln = math.rand.intn(100) + 100 
 buf = math.rand.bytes(ln) 

 start = math.rand.intn(90) 
 substr = buf[start:start+10] 

assert Index(buf, substr) == start 
