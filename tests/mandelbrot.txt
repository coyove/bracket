 limit = 4.0 
 maxIter = 50 
 rows = 0 
 bytesPerRow = 0 
 initial_r = 0 
 initial_i = 0 
 ctr = 0 
 renderRow =  fun(y0) {
     i=0
     j=0
     x=0
     res=0
     b=0
     Zr1=0
     Zr2=0
     Zi1=0
     Zi2=0
     Tr1=0
     Tr2=0
     Ti1=0
     Ti2 = 0 
     row = "" 
     xByte = 0  for (xByte < bytesPerRow) {
        res = 0 
         Ci = initial_i[y0] 

        i = 0  for (i<8) {
            x = xByte<<3 
             Cr1 = initial_r[x+i] 
             Cr2 = initial_r[x+i+1] 

            Zr1=Cr1 
            Zi1=Ci 
            Zr2=Cr2 
            Zi2=Ci 

            b=0 

            j = 0  for (j < maxIter) {
                Tr1=Zr1*Zr1 
                Ti1=Zi1*Zi1 
                Zi1=(2*Zr1*Zi1)+Ci 
                Zr1=(Tr1-Ti1)+Cr1 

                if (Tr1+Ti1>limit) {
                    b = b | 2 
                    if (b == 3) {break }
                }

                Tr2 = Zr2*Zr2 
                Ti2 = Zi2*Zi2 
                Zi2 = (2*Zr2*Zi2)+Ci 
                Zr2 = Tr2-Ti2+Cr2 

                if (Tr2+Ti2>limit) {
                    b = b | 1 
                    if (b == 3) break 
                }
                j=j+1 
            }

            res = res<<2 | b 
            i=i+2 
        }

        row = row + std.char(~res) 
        xByte=xByte+1 
    }

    return row 
} 

size = 1600
nCPU = 4
bytesPerRow = size >> 3 

initial_r = std.genlist(size) 
initial_i = std.genlist(size) 

inv = 2 / size 
for xy =0, size {
     i = inv * xy 
    initial_r[xy] = i - 1.5 
    initial_i[xy] = i - 1.0 
}
 

rows = std.genlist(size) 
y = -1 
mux = std.sync.mutex() 
wg = std.sync.waitgroup() 
wg.add(nCPU)

 worker =  fun() {
    for (y < size) {
        mux.lock() 
        y = y + 1 
         y0 = y 
        mux.unlock() 
        if (y0 < size) {
            rows[y0] = renderRow(y0) 
        } 
    }
    wg.done() 
} 

for i = 0, nCPU std.sync.run(worker)  

wg.wait() 
 
// io.write("P4\n" + itoa(size) + " " + itoa(size) + "\n") 
// for rows ,func (i, row) {
//     io.write(row) 
// }
