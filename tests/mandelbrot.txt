

set limit = 4.0
set maxIter = 50
set rows = 0
set bytesPerRow = 0
set initial_r = 0
set initial_i = 0
set ctr = 0
set renderRow = lambda(y0)
    set i,j,x,res,b,Zr1,Zr2,Zi1,Zi2,Tr1,Tr2,Ti1,Ti2 = 0
    set row = bytes(bytesPerRow) 
    set xByte = 0 while xByte < bytesPerRow do
        res = 0
        set Ci = initial_i[y0]

        i = 0 while i<8 do
            x = xByte<<3
            set Cr1 = initial_r[x+i]
            set Cr2 = initial_r[x+i+1]

            Zr1=Cr1
            Zi1=Ci
            Zr2=Cr2
            Zi2=Ci

            b=0

            j = 0 while j < maxIter do
                Tr1=Zr1*Zr1
                Ti1=Zi1*Zi1
                Zi1=(2*Zr1*Zi1)+Ci
                Zr1=(Tr1-Ti1)+Cr1

                if (Tr1+Ti1)>limit then
                    b = b | 2
                    if b == 3 then break end
                end

                Tr2 = Zr2*Zr2
                Ti2 = Zi2*Zi2
                Zi2 = (2*Zr2*Zi2)+Ci
                Zr2 = Tr2-Ti2+Cr2

                if (Tr2+Ti2)>limit then
                    b = b | 1
                    if b == 3 then break end
                end
                j=j+1
            end

            res = res<<2 | b
            i=i+2
        end

        row[xByte] = ~res
        xByte=xByte+1
    end

    return row
end

set size = 1600
bytesPerRow = size >> 3
out_println(bytesPerRow, size >> 3)

initial_r = list_make_len(size)
initial_i = list_make_len(size)

set inv = 2 / size
set xy = 0 while xy < size do
    set i = inv * xy
    initial_r[xy] = i - 1.5
    initial_i[xy] = i - 1.0
    xy = xy + 1
end

rows = list_make_len(size)
set y = -1
set mux = mutex_new()
set wg = wait_group_new()
wait_group_add(wg,4)

set worker = lambda()
    while y < size do
        mutex_lock(mux)
        y = y + 1
        set y0 = y
        mutex_unlock(mux)
        if y0 < size then rows[y0] = renderRow(y0) end
    end
    wait_group_done(wg)
end

go(worker) 
go(worker) 
go(worker) 
go(worker)
wait_group_wait(wg)


